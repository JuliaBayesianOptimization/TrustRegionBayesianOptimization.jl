"""
A policy from TuRBO algorithm for deciding where to sample next.
"""
struct TurboPolicy{T<:Real} <: AbstractPolicy
    # for each TR use candidate_size many points to approximate a sample function
    # drawn from the posterior (Thompson sample)
    candidate_size::Int
    prob_of_perturbation::T
end

# default values from the TuRBO paper
function TurboPolicy(
    oh::OptimizationHelper;
    candidate_size = min(100 * get_dimension(oh), 5000),
    prob_of_perturbation = min(20.0 / get_dimension(oh), 1),
)
    return TurboPolicy(candidate_size, prob_of_perturbation)
end

# Thompson sample across trust regions
function AbstractBayesianOptimization.next_batch!(
    policy::TurboPolicy,
    dsm::Turbo{J,D,R},
    oh::OptimizationHelper,
) where {J,D<:Real,R<:Real}
    @assert D == get_domain_eltype(oh)
    @assert R == get_range_type(oh)

    next_points = Vector{Vector{D}}(undef, dsm.batch_size)
    for j = 1:(dsm.batch_size)
        # sample a function from the posterior for each TR (discretized version on
        # candidate_size many points generated by modified Sobol sequence)
        combined_xs = Vector{Vector{D}}()
        combined_ys = Vector{R}()
        for i = 1:(dsm.n_surrogates)
            tr_xs = turbo_policy_seq(
                dsm,
                policy.candidate_size,
                policy.prob_of_perturbation,
                get_dimension(oh),
                i,
            )
            tr_ys = rand(dsm.surrogates[i], tr_xs)
            append!(combined_xs, tr_xs)
            append!(combined_ys, tr_ys)
        end
        next_points[j] = combined_xs[argmax(combined_ys)]
    end
    return next_points
end

function turbo_policy_seq(dsm::Turbo{J, D}, candidate_size, prob_of_perturbation, dimension, i) where {J, D}
    xs = Vector{Vector{D}}()
    # following the construction from the paper: supplement material part D; and python implementation
    for perturbation in (
        from_unit_cube(next!(dsm.sobol_generator), dsm.trs[i].lb, dsm.trs[i].ub) for
        _ = 1:candidate_size
    )
        x = copy(dsm.trs[i].center)
        # each index is chosen with probability prob_of_perturbation
        for k = 1:dimension
            if rand() <= prob_of_perturbation
                x[k] = perturbation[k]
            end
        end
        push!(xs, x)
    end
    return xs
end
